C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE PROC_SYSTEM_INTERRUPT
OBJECT MODULE PLACED IN .\Proc_System_Interrupt.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\C_Source\S0_System\Proc_System_Interrupt.c LARGE BROWSE INCDIR(..\C_Sour
                    -ce\S0_System;..\C_Source\S1_HardDrv;..\C_Source\S2_MyLib;..\C_Source\S3_ApiPlat;..\C_Source\S4_ApiUser;..\C_Source\S5_Ap
                    -iProtocol;..\C_Source\S6_MyIncludes;..\C_Source\S1_HardDrv\V9811A_EMU;..\C_Source\S1_HardDrv\V9811A_MCU;..\C_Source\S1_H
                    -ardDrv\E2P_24CXXX) DEBUG OBJECTEXTEND PRINT(.\Proc_System_Interrupt.lst) OBJECT(.\Proc_System_Interrupt.obj)

line level    source

   1          /*
   2          *****************Copyright (c)*************************************
   3          **      Hangzhou Xili Watthour Meter Manufacture Co., Ltd. 
   4          **--------------file info--------------------------------------------
   5          **name                  : Proc_System_Interrupt.c
   6          **Author                : maji
   7          **date                  : 2016-04-20
   8          **description   : ÏµÍ³ÖÐ¶ÏÏòÁ¿´¦ÀíÏà¹ØC´úÂë
   9          **note                  : V9811A £¬MERTER FOR DL03C
  10          **--------------------Version History -------------------------------------
  11          ** NO. Date         Ver      By         Description 
  12          **==============================================================
  13          ** 1   2016-04-26   v01.00   sosomj     1. frist version                             
  14          **
  15          **==============================================================
  16          */
  17          
  18          #include <MyIncludes_H.h>
  19          
  20          
  21          
  22          
  23          //=======================================================
  24          //º¯ÊýÃû£ºInterrupt_Int0
  25          //º¯Êý×÷ÓÃ£º¶Ë¿ÚÖÐ¶Ï0£¬ÖÐ¶ÏÏòÁ¿                         £¨03H£©
  26          //======================================================= 
  27          void Interrupt_Int0 (void) interrupt 0 using 2
  28          {
  29   1          TCON &= ~BIT1;
  30   1      //  user coding begin
  31   1      //    Int0();           
  32   1      }
  33          //=======================================================
  34          //º¯ÊýÃû£ºInterrupt_Timer0
  35          //º¯Êý×÷ÓÃ£ºÄÚºËtimer0ÖÐ¶Ï£¬ÖÐ¶ÏÏòÁ¿            £¨0BH£©
  36          //Ó¦ÓÃËµÃ÷: 10ms¶¨Ê±
  37          //======================================================= 
  38          void Interrupt_Timer0 (void) interrupt 1 using 2
  39          {
  40   1      
  41   1          TL0  = LOBYTE(T0_10MS_CNT);         //10ms
  42   1          TH0  = HIBYTE(T0_10MS_CNT);
  43   1      
  44   1          // user coding begin
  45   1          gs_sys_run.back_fg |= BIT0_FONT_FG_10MS;   //ÅäÖÃ10ms±êÊ¶ÓÐÐ§ //
  46   1      
  47   1          if(gs_uart_iec_app_var[UART_CH0_IR].iec_status!=0) gs_uart_iec_app_var[UART_CH0_IR].delay_10ms++;
  48   1          if(gs_uart_iec_app_var[UART_CH0_IR].tx_delay_flg ==TRUE )
  49   1          {
  50   2              if(gs_uart_iec_app_var[UART_CH0_IR].tx_ready_10ms>0)  gs_uart_iec_app_var[UART_CH0_IR].tx_ready_10
             -ms --;
  51   2          }
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 2   

  52   1         
  53   1      
  54   1              gs_sys_globaL_var.qf_time++;
  55   1      
  56   1              
  57   1      }
  58          
  59          //=======================================================
  60          //º¯ÊýÃû£ºInterrupt_Int1
  61          //º¯Êý×÷ÓÃ£º¶Ë¿ÚÖÐ¶Ï1£¬ÖÐ¶ÏÏòÁ¿                         £¨13H£©
  62          //======================================================= 
  63          void Interrupt_Int1 (void) interrupt 2 using 2
  64          {
  65   1          TCON &= ~BIT3;
  66   1      }
  67          //=======================================================
  68          //º¯ÊýÃû£ºInterrupt_Timer1
  69          //º¯Êý×÷ÓÃ£ºÄÚºËtimer1ÖÐ¶Ï£¬ÖÐ¶ÏÏòÁ¿            £¨1BH£©
  70          //======================================================= 
  71          void Interrupt_Timer1 (void) interrupt 3 using 2
  72          {
  73   1          TCON &= ~BIT7;
  74   1              
  75   1              TL1  = LOBYTE(T1_80MS_CNT);         //10ms
  76   1          TH1  = HIBYTE(T1_80MS_CNT);
  77   1      //      P9DO |= BIT2;
  78   1      ////    UART4_INITLIZE_OFF();
  79   1      ////    UART4_TX_DIR_OUT();
  80   1      ////    P21FS = 0;
  81   1              UART4_TX_HIGH();                //³öÂö³å½«½üºìÍâµÆÖÃµÍ
  82   1      ////    P2OD &= ~PIN_UART4_TX;
  83   1              TR1 = 0;
  84   1              ET1 = 0;
  85   1      
  86   1      
  87   1      // user coding begin
  88   1      
  89   1      }
  90          
  91          //=======================================================
  92          //º¯ÊýÃû£ºInterrupt_Timer2
  93          //º¯Êý×÷ÓÃ£ºÄÚºËtimer2ÖÐ¶Ï£¬ÖÐ¶ÏÏòÁ¿            £¨2BH£©
  94          //======================================================= 
  95          void Interrupt_Timer2 (void) interrupt 5 using 2
  96          {
  97   1              T2CON &= ~BIT7;
  98   1         //user coding begin
  99   1      //   if(gs_measure_var_data.gs_really[PHASE_TT].dw_i_val.u32 > 10000)
 100   1      //   {
 101   1                      TL2  = LOBYTE(T2_01MS_CNT);         //5ms
 102   1                      TH2  = HIBYTE(T2_01MS_CNT);
 103   1      //   }
 104   1      //   else
 105   1      //   {
 106   1      //              TL2  = LOBYTE(T0_10MS_CNT);         //10ms
 107   1      //          TH2  = HIBYTE(T0_10MS_CNT);
 108   1      //   }
 109   1              CLRWDT(); 
 110   1              api_handl_bar_display_1ms();
 111   1      //       gs_sys_run.back_fg |= BIT3_FONT_FG_1MS;
 112   1              
 113   1      }
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 3   

 114          
 115          //=======================================================
 116          //º¯ÊýÃû£ºInterrupt_Uart1
 117          //º¯Êý×÷ÓÃ£ºÄÚºËuart1ÖÐ¶Ï£¬ÖÐ¶ÏÏòÁ¿                     £¨3BH£©
 118          //=======================================================
 119          void Interrupt_Uart1 (void) interrupt 7 using 2
 120          {
 121   1          if (SCON1 & BIT0)
 122   1          {// ½ÓÊÜÖÐ¶Ï±ê¼Ç
 123   2              SCON1 &= ~BIT0;
 124   2              // user coding begin
 125   2          }
 126   1          else if (SCON1 & BIT1)
 127   1          {// ·¢ËÍÖÐ¶Ï±ê¼Ç
 128   2              SCON1 &= ~BIT1;
 129   2              // user coding begin
 130   2          }
 131   1      }
 132          
 133          
 134          //=======================================================
 135          //º¯ÊýÃû£ºInterrupt_ExInt2
 136          //º¯Êý×÷ÓÃ£ºÍâ²¿ÖÐ¶Ï2£¬ÖÐ¶ÏÏòÁ¿                         £¨43H£©
 137          //×¢Òâ£ºÏÈÇåÀ©Õ¹ÖÐ¶Ï±êÖ¾Î»£¬ºóÇåÄÚºËÖÐ¶Ï±êÖ¾Î»
 138          //=======================================================
 139          void Interrupt_ExInt2 (void) interrupt 8 using 2
 140          {
 141   1       uint8 buf;
 142   1       uint8 temp_ifg;
 143   1      
 144   1          temp_ifg = ExInt2IE & ExInt2IFG;        // ·ÀÖ¹¶ÔÎ´Ê¹ÄÜÖÐ¶ÏµÄÎ»²Ù×÷ //
 145   1      
 146   1      ////////////////////////////////////////////////////////////////////////
 147   1      //  UART2  TX   START
 148   1      ////////////////////////////////////////////////////////////////////////
 149   1      //    if (temp_ifg & BIT0)
 150   1      //    {// uart2 translate interrupt flag
 151   1      //        ExInt2IFG &= ~BIT0;        //BIT0, ExInt2IFG·¢ËÍÖÐ¶Ï±êÊ¶ //
 152   1      //        SCON2 &= ~BIT1;           //BIT1 , UART2µÄSCON2ÖÐµÄ·¢ËÍÖÐ¶Ï±êÊ¶ //
 153   1      //        // user coding begin
 154   1      //        if (gs_uart_drv_var[UART_CH0_IR].tx_len>0)
 155   1      //        {
 156   1      //            buf=(gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index]);
 157   1      //            if(gs_uart_drv_var[UART_CH0_IR].bits_len==7)
 158   1      //           {
 159   1      //                 // 7Î»Êý¾Ý´¦Àí·½Ê½ //
 160   1      //                 ACC=(buf &0x7F);
 161   1      //                if(P)
 162   1      //                {
 163   1      //                    buf |= BIT7;
 164   1      //                }
 165   1      //                else
 166   1      //                {
 167   1      //                    buf&= ~BIT7;
 168   1      //                }
 169   1      //            }
 170   1      //            SBUF2 = buf;
 171   1      //            gs_uart_iec_app_var[UART_CH0_IR].delay_10ms = 0;   // ÓÐÊý¾Ý´¦ÀíÊ±Çå³ýÑÓÊ±¼ÆÊýÆ÷ //
 172   1      //            gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index] =0;
 173   1      //            gs_uart_drv_var[UART_CH0_IR].buff_index++;
 174   1      //            gs_uart_drv_var[UART_CH0_IR].tx_len -- ;
 175   1      //        }
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 4   

 176   1      //        else
 177   1      //        {
 178   1      //            //·¢ËÍÍê³É  //
 179   1      //            gs_uart_drv_var[UART_CH0_IR].buff_index = 0;
 180   1      //            gs_uart_drv_var[UART_CH0_IR].status = UART_STATUS_BUSY_TX_OVER;  
 181   1      //                                        En_UART4_rx();
 182   1      //                                        Init_UART_soft(UART_CH0_IR);
 183   1      //        }
 184   1      //    }
 185   1      
 186   1      //////////////////////////////////////////////////////////////////////////
 187   1      ////  UART2  TX         END
 188   1      //////////////////////////////////////////////////////////////////////////
 189   1      
 190   1      
 191   1      //////////////////////////////////////////////////////////////////////////
 192   1      ////  UART2  RX         START
 193   1      //////////////////////////////////////////////////////////////////////////
 194   1      //    if (temp_ifg & BIT1)
 195   1      //    {// uart2 receive interrupt flag
 196   1      //        ExInt2IFG &= ~BIT1;
 197   1      //        SCON2 &= ~BIT0;
 198   1      //        // user coding begin
 199   1      //        buf = SBUF2;
 200   1      //        gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index] = buf&0x7f;//  7Î»Êý¾
             -ÝÎ»//
 201   1      //        gs_uart_iec_app_var[UART_CH0_IR].delay_10ms = 0;   // ÓÐÊý¾Ý´¦ÀíÊ±Çå³ýÑÓÊ±¼ÆÊýÆ÷ //
 202   1      //        gs_uart_drv_var[UART_CH0_IR].buff_index++;
 203   1      //        if(gs_uart_drv_var[UART_CH0_IR].buff_index>4)
 204   1      //        {
 205   1      //            NOP();
 206   1      //            NOP();
 207   1      //        }
 208   1      //            gs_uart_drv_var[UART_CH0_IR].buff_index %= UART_BUFF_SIZE;
 209   1      //        if(gs_uart_drv_var[UART_CH0_IR].buff_index>0x15)
 210   1      //        {
 211   1      //            NOP();
 212   1      //            NOP();
 213   1      //        }
 214   1      //    }
 215   1      ////////////////////////////////////////////////////////////////////////
 216   1      //  UART2  RX   END
 217   1      ////////////////////////////////////////////////////////////////////////
 218   1      
 219   1      
 220   1      ////////////////////////////////////////////////////////////////////////
 221   1      //  UART4  TX   START
 222   1      ////////////////////////////////////////////////////////////////////////
 223   1          if (temp_ifg & BIT2)
 224   1          {// uart4 translate interrupt flag
 225   2              ExInt2IFG &= ~BIT2;
 226   2              SCON4 &= ~BIT1;
 227   2                      if (gs_uart_drv_var[UART_CH0_IR].tx_len>0)
 228   2                 {
 229   3                         buf=(gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index]);
 230   3                         if(gs_uart_drv_var[UART_CH0_IR].bits_len==7)
 231   3                        {
 232   4                                      // 7Î»Êý¾Ý´¦Àí·½Ê½ //
 233   4                                      ACC=(buf &0x7F);
 234   4                                 if(P)
 235   4                                 {
 236   5                                         buf |= BIT7;
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 5   

 237   5                                 }
 238   4                                 else
 239   4                                 {
 240   5                                         buf&= ~BIT7;
 241   5                                 }
 242   4                         }
 243   3                         SBUF4 = buf;
 244   3                         gs_uart_iec_app_var[UART_CH0_IR].delay_10ms = 0;   // ÓÐÊý¾Ý´¦ÀíÊ±Çå³ýÑÓÊ±¼ÆÊýÆ÷ //
 245   3                         gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index] =0;
 246   3                         gs_uart_drv_var[UART_CH0_IR].buff_index++;
 247   3                         gs_uart_drv_var[UART_CH0_IR].tx_len -- ;
 248   3                 }
 249   2                 else
 250   2                 {
 251   3                         //·¢ËÍÍê³É  //
 252   3                         gs_uart_drv_var[UART_CH0_IR].buff_index = 0;
 253   3                         gs_uart_drv_var[UART_CH0_IR].status = UART_STATUS_BUSY_TX_OVER;      
 254   3                   En_UART4_rx(); 
 255   3                               Init_UART_soft(UART_CH0_IR);   
 256   3                       }
 257   2               /*Uart4_Transmit();
 258   2              // user coding begin
 259   2          if(gs_RacCtrl.ucStatus==Rac_Send)
 260   2          {
 261   2            if(gs_RacCtrl.ucSendPoint<gs_RacCtrl.ucSendLen)   
 262   2            {
 263   2              i=Lib_check_bitnum(gs_RacCtrl.ucBuf[gs_RacCtrl.ucSendPoint]);            //·¢ËÍÆæÐ£ÑéÎ»
 264   2              if(i==0)
 265   2              {    
 266   2                SCON4 |=0x08;                        //Å¼Ð£ÑéµÄÖµ  0x1906µÄbit3 1
 267   2              }
 268   2              else
 269   2              {    
 270   2                SCON4 &=0xf7;                  //ÆæÐ£ÑéµÄÖµ  0x1906µÄbit3 0
 271   2              }
 272   2              SBUF4 = gs_RacCtrl.ucBuf[gs_RacCtrl.ucSendPoint++];
 273   2            }
 274   2            else
 275   2            {
 276   2              gs_RacCtrl.ucStatus=Rac_Rev;  
 277   2            }                                                                                                                         
 278   2          }*/
 279   2         }
 280   1      ////////////////////////////////////////////////////////////////////////
 281   1      //  UART4  TX   END
 282   1      ////////////////////////////////////////////////////////////////////////
 283   1      
 284   1      
 285   1      ////////////////////////////////////////////////////////////////////////
 286   1      //  UART4  RX   START
 287   1      ////////////////////////////////////////////////////////////////////////
 288   1          if (temp_ifg & BIT3)
 289   1          {
 290   2                      // uart4 receive interrupt flag
 291   2              ExInt2IFG &= ~BIT3;
 292   2              SCON4 &= ~BIT0;
 293   2                      buf = SBUF4;
 294   2                         gs_uart_drv_var[UART_CH0_IR].buff[gs_uart_drv_var[UART_CH0_IR].buff_index] = buf&0x7f;//  7Î»Êý¾ÝÎ»//
 295   2                         gs_uart_iec_app_var[UART_CH0_IR].delay_10ms = 0;   // ÓÐÊý¾Ý´¦ÀíÊ±Çå³ýÑÓÊ±¼ÆÊýÆ÷ //
 296   2                         gs_uart_drv_var[UART_CH0_IR].buff_index++;
 297   2                         if(gs_uart_drv_var[UART_CH0_IR].buff_index>4)
 298   2                         {
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 6   

 299   3                                 NOP();
 300   3                                 NOP();
 301   3                         }
 302   2                      gs_uart_drv_var[UART_CH0_IR].buff_index %= 250;//UART_BUFF_SIZE;
 303   2                      if(gs_uart_drv_var[UART_CH0_IR].buff_index>0x15)
 304   2                      {
 305   3                              NOP();
 306   3                              NOP();
 307   3                      }
 308   2             /* if(gs_RacCtrl.ucStatus==Rac_Rev)
 309   2              {
 310   2                  if(gs_RacCtrl.ucRevPoint<gs_RacCtrl.ucRevLen)
 311   2                  {
 312   2                      gs_RacCtrl.ucBuf[gs_RacCtrl.ucRevPoint++]=SBUF4;
 313   2                      if(gs_RacCtrl.ucRevPoint==gs_RacCtrl.ucRevLen)
 314   2                      {
 315   2                          gs_RacCtrl.ucStatus=Rac_WaitPro;
 316   2                      //    if( gs_RacPhy.uc_Sendstat == true)  
 317   2                        //  {
 318   2                        //     gs_sys_run.font_fg |= BIT0_FONT_FG_readpower; // µçÁ¿¶ÁÈ¡ÊÂ¼þÍê³É±êÊ¶
 319   2                       //   }
 320   2                      }
 321   2                  }
 322   2              }*/
 323   2      
 324   2          }
 325   1      ////////////////////////////////////////////////////////////////////////
 326   1      //  UART4  RX   END
 327   1      ////////////////////////////////////////////////////////////////////////
 328   1      
 329   1      
 330   1          if (temp_ifg & BIT4)
 331   1          {// uart2timer0 interrupt
 332   2              ExInt2IFG &= ~BIT4;
 333   2              // user coding begin  
 334   2          }
 335   1          if (temp_ifg & BIT5)
 336   1          {// uart4timer0 interrupt
 337   2              ExInt2IFG &= ~BIT5;
 338   2              // user coding begin    
 339   2          }
 340   1          if (temp_ifg & BIT6)
 341   1          {// flash erase interrupt
 342   2              ExInt2IFG &= ~BIT6;
 343   2              // user coding begin  
 344   2          }
 345   1      
 346   1      ////////////////////////////////////////////////////////////////////////
 347   1      //   ACTIVE ENERGY PLUSE accumulate     START
 348   1      ////////////////////////////////////////////////////////////////////////
 349   1          if (temp_ifg & BIT7)
 350   1          {// CF impluse interrupt
 351   2              ExInt2IFG &= ~BIT7;
 352   2              // user coding begin
 353   2                gs_energy_var.pluse[1]++;    //ÓÐ¹¦×ÜµçÄÜÀÛ¼Æ //
 354   2         //  gs_mot_drv_var.u8_cnt ++;
 355   2          }
 356   1      ////////////////////////////////////////////////////////////////////////
 357   1      //   ACTIVE ENERGY PLUSE accumulate     END
 358   1      ////////////////////////////////////////////////////////////////////////
 359   1      
 360   1      
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 7   

 361   1          EXIF &= ~BIT4;
 362   1      }
 363          
 364          //=======================================================
 365          //º¯ÊýÃû£ºInterrupt_ExInt3
 366          //º¯Êý×÷ÓÃ£ºÍâ²¿ÖÐ¶Ï3£¬ÖÐ¶ÏÏòÁ¿                         £¨4BH£© 
 367          //×¢Òâ£ºÏÈÇåÀ©Õ¹ÖÐ¶Ï±êÖ¾Î»£¬ºóÇåÄÚºËÖÐ¶Ï±êÖ¾Î»          
 368          //=======================================================
 369          void Interrupt_ExInt3 (void) interrupt 9 using 2
 370          {
 371   1       unsigned char temp_ifg;
 372   1              
 373   1          temp_ifg = ExInt3IE & ExInt3IFG;
 374   1          if (temp_ifg & BIT4)
 375   1          {// uart3timer0 interrupt
 376   2             ExInt3IFG &= ~BIT4;
 377   2              // user coding begin   
 378   2          }
 379   1              if (temp_ifg & BIT5)//UART5 ÖÐÆÕÍ¨¶¨Ê±Æ÷Òç³öÖÐ¶Ï
 380   1          {// uart3timer0 interrupt
 381   2             ExInt3IFG &= ~BIT5;
 382   2              // user coding begin   
 383   2          }                   
 384   1          if (temp_ifg & BIT6)
 385   1          {// rtc interrupt
 386   2              ExInt3IFG &= ~BIT6;
 387   2              // user coding begin  
 388   2             gs_sys_run.back_fg |= BIT1_BACK_FG_RTC;   //ÅäÖÃÏÔÊ¾°´¼ü±êÊ¶ÓÐÐ§ //  //  RTC Ã¿Ãë²úÉúµÄÖÐ¶Ï  //
 389   2              gs_emu_adj_var.sec_flg=TRUE;           // Ó²¼þ¶Ì½ÓÐ£±íÃë¶¨Ê±±êÊ¶ //
 390   2      
 391   2          }
 392   1      
 393   1      
 394   1          if (temp_ifg & BIT7)        //  ÎÞ¹¦
 395   1          {// CF2 interrupt
 396   2              ExInt3IFG &= ~BIT7;
 397   2                  gs_energy_var.pluse[0]++;    //ÓÐ¹¦×ÜµçÄÜÀÛ¼Æ //
 398   2                      ///////////////////////////////////////////////////
 399   2                      //²âÊÔÄ£Ê½ÏÂ½üºìÍâÊä³öÂö³å               cxy 2019-04-02
 400   2                      if(IsModeTest == TRUE)
 401   2                      {
 402   3                              UART4_FUNC_DIS();
 403   3                              UART4_TX_LOW();
 404   3                              UART4_TX_DIR_OUT() ;
 405   3      //                      //³öÂö³å½«½üºìÍâµÆÖÃ¸ß 
 406   3      //                      P9DO &= ~BIT2;//ÖÃ¸ß¹Ø±Õ±¨¾¯µÆ
 407   3      //                      //¿ªÆô80ms¶¨Ê±Æ÷
 408   3                              TL1      = LOBYTE(T1_80MS_CNT);    //80ms  Timer1
 409   3                              TH1      = HIBYTE(T1_80MS_CNT);
 410   3                              Start_Timer1();
 411   3                      }
 412   2                      else
 413   2                      {       //¹Ø±Õ80ms¶¨Ê±Æ÷
 414   3                              TR1 = 0;
 415   3                              ET1 = 0;
 416   3                      }
 417   2                      //ÏÔÊ¾ÈýÌõ¿¸±íÊ¾Âö³åËÙÂÊcoding  //Çå¿ÕÈýÌõ¸Ü
 418   2                      gs_dis_pixel_var.dis_buff[10] &= ~(BIT7+BIT6+BIT5);
 419   2                      if(MD_dis_delay == 0)
 420   2                      {
 421   3                              Write_LCD(&gs_dis_pixel_var.dis_buff[0]);
 422   3                      }
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 8   

 423   2                      else
 424   2                      {
 425   3                              Full_SEG(0xFF);
 426   3                      }
 427   2                      Bar_No = 0;//½ø¶ÈÌõµÈÓÚ0ËµÃ÷ÈýÌõ¿¸ÊÇ±»Çå¿ÕµÄ
 428   2                      //t_count = 0;
 429   2                      TL2  = LOBYTE(T2_01MS_CNT); 
 430   2                      TH2      = HIBYTE(T2_01MS_CNT);
 431   2                      TR2 = 1;
 432   2                      ET2 = 1;
 433   2                      //¿ªÆô¶¨Ê±Æ÷
 434   2              //////////////////////////////////////////////////
 435   2          }
 436   1          EXIF &= ~BIT5;
 437   1      }
 438          //=======================================================
 439          //º¯ÊýÃû£ºInterrupt_ExInt4
 440          //º¯Êý×÷ÓÃ£ºÍâ²¿ÖÐ¶Ï4£¬ÖÐ¶ÏÏòÁ¿                         £¨53H£©
 441          //×¢Òâ£ºÏÈÇåÀ©Õ¹ÖÐ¶Ï±êÖ¾Î»£¬ºóÇåÄÚºËÖÐ¶Ï±êÖ¾Î»
 442          //======================================================= 
 443          void Interrupt_ExInt4 (void) interrupt 10 using 2
 444          {
 445   1      
 446   1       unsigned char temp_ifg;
 447   1       
 448   1          temp_ifg = ExInt4IE & ExInt4IFG;
 449   1      //    if (temp_ifg & BIT0)
 450   1      //    {
 451   1      //        ExInt4IFG &= ~BIT0;
 452   1      //        // user coding begin   
 453   1      //    }
 454   1      //    if (temp_ifg & BIT1)
 455   1      //    {
 456   1      //        ExInt4IFG &= ~BIT1;
 457   1      //        // user coding begin    
 458   1      //    }
 459   1      //    if (temp_ifg & BIT2)
 460   1      //    {
 461   1      //        ExInt4IFG &= ~BIT2;
 462   1      //        // user coding begin    
 463   1      //    }
 464   1          if (temp_ifg & BIT3)
 465   1          {
 466   2              
 467   2      
 468   2                       ExInt4IFG &= ~BIT3;
 469   2              // user coding begin   
 470   2          }
 471   1      
 472   1         
 473   1          EXIF &= ~BIT6;
 474   1      }
 475          
 476          //=======================================================
 477          //º¯ÊýÃû£ºInterrupt_PF
 478          //º¯Êý×÷ÓÃ£ºÏµÍ³µôµçÔ¤¾¯ÖÐ¶Ï£¬ÖÐ¶ÏÏòÁ¿          £¨63H£©
 479          //======================================================= 
 480          /*void Interrupt_PF (void) interrupt 12 using 2
 481          {// powerdown interrupt
 482              EICON &= ~BIT3;
 483              // user coding begin
 484              Int27();    
C51 COMPILER V9.01   PROC_SYSTEM_INTERRUPT                                                 04/11/2019 19:08:06 PAGE 9   

 485          }*/
 486                  
 487          
 488          
 489          /***************************************************************
 490          *    END
 491          ****************************************************************/
 492          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    776    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
