C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LNK_EMU_HANDL
OBJECT MODULE PLACED IN .\Lnk_EMU_handl.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\C_Source\S1_HardDrv\V9811A_EMU\Lnk_EMU_handl.c LARGE BROWSE INCDIR(..\C_
                    -Source\S0_System;..\C_Source\S1_HardDrv;..\C_Source\S2_MyLib;..\C_Source\S3_ApiPlat;..\C_Source\S4_ApiUser;..\C_Source\S
                    -5_ApiProtocol;..\C_Source\S6_MyIncludes;..\C_Source\S1_HardDrv\V9811A_EMU;..\C_Source\S1_HardDrv\V9811A_MCU;..\C_Source\
                    -S1_HardDrv\E2P_24CXXX) DEBUG OBJECTEXTEND PRINT(.\Lnk_EMU_handl.lst) OBJECT(.\Lnk_EMU_handl.obj)

line level    source

   1          /*
   2          *****************Copyright (c)*************************************
   3          **      Hangzhou Xili Watthour Meter Manufacture Co., Ltd. 
   4          **--------------file info--------------------------------------------
   5          **name                  : Lnk_EMU_handl.c
   6          **Author                : maji
   7          **date                  : 2016-04-20 
   8          **description   : V9811AµÄEMU¼ÆÁ¿Ä£¿éÁ´Â·²ã´¦ÀíC´úÂë
   9          **note                  : V9811A £¬MERTER FOR DL03C
  10          **--------------------Version History -------------------------------------
  11          ** NO. Date         Ver      By         Description 
  12          **==============================================================
  13          ** 1   2016-04-26   v01.00   sosomj     1. frist version                             
  14          **
  15          **==============================================================
  16          */
  17          
  18          #include <MyIncludes_H.h>
  19          
  20          
  21          EMU_RUN_VAR   gs_emu_run_var;
  22          
  23          /*********************************************************************************************************
  24          ** º¯ÊıÃû³Æ: Init_EMU
  25          ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯EMU
  26          ** Èë¿Ú²ÎÊı: ÎŞ
  27          ** ³ö¿Ú²ÎÊı: ÎŞ
  28          ********************************************************************************************************/
  29          
  30          
  31          void Init_EMU_RAM(void)
  32          {
  33   1          Get_EMU_AdjParam();
  34   1      }
  35          
  36          
  37          /*********************************************************************************************************
  38          ** º¯ÊıÃû³Æ: Init_EMU
  39          ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯EMU
  40          ** Èë¿Ú²ÎÊı: ÎŞ
  41          ** ³ö¿Ú²ÎÊı: ÎŞ
  42          ********************************************************************************************************/
  43          void Init_EMU(uint8 u8_mode)
  44          {
  45   1      
  46   1      #if meter_type == D_1P3W
  47   1          if(u8_mode==SLEEP_MODE)
  48   1          {
  49   2              CtrlADC5=0X80;     //¹Ø±ÕMÍ¨µÀ //
  50   2              CtrlADC6=0;         //¹Ø±ÕËùÓĞAD²ÉÑù //  
  51   2              PMG=1;              //¹Ø±Õ¼ÆÁ¿Ê±ÖÓ  //
  52   2              return;
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 2   

  53   2          }
  54   1      
  55   1          PMG=0;              //´ò¿ª¼ÆÁ¿Ê±ÖÓ  //
  56   1          //step1  //
  57   1          SetMeterCfgACK(0x00,PMCtrl4);   //¹Ø±ÕÄÜÁ¿ÀÛ¼Ó¡¢CF Êä³öÒÔ¼°Æğ¶¯/Ç±¶¯ÅĞ¶ÏµçÂ· //
  58   1          SetMeterCfgACK(0x00,PMCtrl1);   // ¹Ø±Õ¼ÆÁ¿Í¨µÀ£¬²¢Í£Ö¹¹¦ÂÊ/ÓĞĞ§Öµ¼ÆËã  //
  59   1          // step2  //
  60   1          CtrlADC5=0X80;   
  61   1          CtrlADC6=0;   
  62   1          if(u8_mode==NORMAL_MODE)
  63   1          {
  64   2              Set_EmuClock(EMUCLK_3M2);          // 3.2M ¼ÆÁ¿Ö÷Æµ //
  65   2              ADCOPEN(ADCAPDN+ADCBPDN+ADCUPDN);//OPEN ADC U  A  B
  66   2              SetMeterCfgACK(0X889374BC,PARABPF);    // ÊÖ²áÒªÇó //
  67   2          }
  68   1          else if((u8_mode ==DLX_MODE)||(u8_mode ==CONST_MODE))
  69   1          {
  70   2              Set_EmuClock(EMUCLK_800k);       // 800K¼ÆÁ¿Ö÷Æµ //
  71   2              ADCOPEN(ADCAPDN+ADCBPDN);//OPEN ADC  A B
  72   2              SetMeterCfgACK(0X911D3C9C,PARABPF);    // ÊÖ²áÒªÇó // 
  73   2          }
  74   1          else
  75   1          {
  76   2              sys_err();          // ÊäÈë²ÎÊıÒì³££¬ËÀÑ­»·ÍË³ö //
  77   2          }
  78   1          CtrlADC0=(ADCA4X+ADCB4X+ADCU2X); //ADC A 4X GAIN  ADC B 4x GAIN ADC U 2sX GAIN      
  79   1      
  80   1          // step3  //
  81   1       
  82   1          SetMeterCfgACK(INITGATEP,GATEP);//ÉèÖÃ¼ÆÁ¿³õÊ¼Öµ
  83   1          SetMeterCfgACK(INITGATEQ,GATEQ);
  84   1      
  85   1          // step4 // 
  86   1      //    SetMeterCfgACK(0,0x10f0);    //0x10f0  PPCNT  ÕıÏò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷  //
  87   1      //    SetMeterCfgACK(0,0x10f1);    //0x10f1  NPCNT  ·´Ïò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷ //
  88   1      //    SetMeterCfgACK(0,0x10f2);    //0x10f2  PPCFCNT  ÕıÏò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
  89   1      //    SetMeterCfgACK(0,0x10f3);   //0x10f3  NPCFCNT  ·´Ïò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
  90   1      //    SetMeterCfgACK(0,0x10f6);   //0x10f6  PQCNT  ÕıÏò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷//
  91   1      //    SetMeterCfgACK(0,0x10f7);   //0x10f7  NQCNT  ·´Ïò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷   //
  92   1      //    SetMeterCfgACK(0,0x10f8);   //0x10f8  PQCFCNT   ÕıÏò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
  93   1      //    SetMeterCfgACK(0,0x10f9);   //0x10f9 NQCFCNT   ·´Ïò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
  94   1      //    // step5// 
  95   1      //    SetMeterCfgACK(0xC8,PMCtrl4);             //  ?????  //
  96   1      //    SetMeterCfgACK(0x08,PMCtrl4);
  97   1      //    SetMeterCfgACK(0x00,PMCtrl4);
  98   1          // step6 // 
  99   1      //    SetMeterCfgACK(0,0x10f0);    //0x10f0  PPCNT  ÕıÏò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷  //
 100   1      //    SetMeterCfgACK(0,0x10f1);    //0x10f1  NPCNT  ·´Ïò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷ //
 101   1      //    SetMeterCfgACK(0,0x10f2);    //0x10f2  PPCFCNT  ÕıÏò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
 102   1      //    SetMeterCfgACK(0,0x10f3);   //0x10f3  NPCFCNT  ·´Ïò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
 103   1      //    SetMeterCfgACK(0,0x10f6);   //0x10f6  PQCNT  ÕıÏò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷//
 104   1      //    SetMeterCfgACK(0,0x10f7);   //0x10f7  NQCNT  ·´Ïò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷   //
 105   1      //    SetMeterCfgACK(0,0x10f8);   //0x10f8  PQCFCNT   ÕıÏò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
 106   1      //    SetMeterCfgACK(0,0x10f9);   //0x10f9 NQCFCNT   ·´Ïò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
 107   1       
 108   1          // step7// 
 109   1          SetMeterCfgACK(0x01,GATECP);//Ç±¶¯1   ,=1»á½ûÖ¹Âö³å·¢³ö    //
 110   1          SetMeterCfgACK(0x01,GATECQ);//Ç±¶¯2   ,=1»á½ûÖ¹Âö³å·¢³ö  //
 111   1      //    SetMeterCfgACK(0x00,DATACP);//Çå³£Êı¹¦ÂÊ¼Ä´æÆ÷ //
 112   1      
 113   1          // step8// 
 114   1          SetMeterCfgACK(0x57,PMCtrl1);//BIT7= 0  ²âÊÔÎ»È·±£Îª0  ; BIT6=1 Ê¹ÄÜ½Ç²îĞ£Õı  //
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 3   

 115   1                                        //BIT5= 0  IA--I1,IB--I2 ; BIT4=1 Ê¹ÄÜPMÊı×ÖĞÅºÅ´¦Àí  //
 116   1                                        //BIT3= 0  ÆÁ±ÎMÍ¨µÀÊı×ÖĞÅºÅÊäÈë; BIT2=1 Ê¹ÄÜI2Êı×ÖĞÅºÅÊäÈëÊ¹ÄÜ  //
 117   1                                        //BIT1= 1   Ê¹ÄÜI1Êı×ÖĞÅºÅÊäÈëÊ¹ÄÜ; BIT0=1 Ê¹ÄÜUÊı×ÖĞÅºÅÊäÈëÊ¹ÄÜ  //
 118   1          SetMeterCfgACK(0x00,PMCtrl2);// Êı×ÖÔöÒæÀàµÄ²ÎÊı¼Ä´æÆ÷£¬ÒªÇóÎª0  //
 119   1      
 120   1          SetMeterCfgACK(0x70,PMCtrl3);//¿ªÆôÁ½Â·ÓĞ¹¦,´øÍ¨ºÍµÍÍ¨ÂË²¨Æ÷ÓĞĞ§ //
 121   1       //   SetMeterCfgACK(0xD2,PMCtrl4);//BIT7= 1 E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯ÅĞ¶ÏÊ¹ÄÜ  ; BIT6=1  E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯Å
             -Ğ¶ÏÊ¹ÄÜ  //
 122   1                                       //BIT5= 1 E2 ÄÜÁ¿ CF Âö³åÊä³ö¿ªÆô; BIT4=1 Ê¹ÄÜE1 ÄÜÁ¿ CF Âö³åÊä³ö //
 123   1                                       //BIT3= 0 ½ûÖ¹ÄÜÁ¿ÀÛ¼ÓºÍÄÜÁ¿Âö³å¼ÆÊı; BIT2=0  E1 ÄÜÁ¿ CF Âö³å´ÓÒı½Å CF1 Ê
             -ä³ö£¬E2 ÄÜÁ¿ CF Âö³å´ÓÒı½Å CF2 Êä³ö  //
 124   1                                       //BIT1:0= 10 ³£Êı¹¦ÂÊ //
 125   1          SetMeterCfgACK(0,0x10f0);    //0x10f0  PPCNT  ÕıÏò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷  //
 126   1          SetMeterCfgACK(0,0x10f1);    //0x10f1  NPCNT  ·´Ïò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷ //
 127   1          SetMeterCfgACK(0,0x10f2);    //0x10f2  PPCFCNT  ÕıÏò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
 128   1          SetMeterCfgACK(0,0x10f3);   //0x10f3  NPCFCNT  ·´Ïò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
 129   1          SetMeterCfgACK(0,0x10f6);   //0x10f6  PQCNT  ÕıÏò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷//
 130   1          SetMeterCfgACK(0,0x10f7);   //0x10f7  NQCNT  ·´Ïò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷   //
 131   1          SetMeterCfgACK(0,0x10f8);   //0x10f8  PQCFCNT   ÕıÏò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
 132   1          SetMeterCfgACK(0,0x10f9);   //0x10f9 NQCFCNT   ·´Ïò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
 133   1          // step9 // 
 134   1          SetMeterCfgACK(0xDE,PMCtrl4);//BIT7= 1  E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯ÅĞ¶ÏÊ¹ÄÜ  ; BIT6=1  E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯ÅĞ
             -¶ÏÊ¹ÄÜ  //
 135   1                                                        //BIT5= 0 E2 ÄÜÁ¿ CF Âö³åÊä³ö¹Ø±Õ; BIT4=1 Ê¹ÄÜE1 ÄÜÁ¿ CF
             - Âö³åÊä³ö //
 136   1                                                        //BIT3= 1 Ê¹ÄÜÄÜÁ¿ÀÛ¼ÓºÍÄÜÁ¿Âö³å¼ÆÊı; BIT2=0  E1 ÄÜÁ¿ CF
             - Âö³å´ÓÒı½Å CF1 Êä³ö£¬E2 ÄÜÁ¿ CF Âö³å´ÓÒı½Å CF2 Êä³ö  //
 137   1                                                        //BIT1:0= 10 ³£Êı¹¦ÂÊ //
 138   1           // step10 // 
 139   1          SetMeterCfgACK(0,PHCCtrl1);//Çå0
 140   1          SetMeterCfgACK(0,PHCCtrl2);//Çå0
 141   1      
 142   1          SetMeterCfgACK(0x01,CFCtrl);           //ÒÔE2Õı·´¾ø¶ÔÖµÀÛ¼ÓÄÜÁ¿ÎªÒÀ¾İ²úÉúCF2  ÒÔE1ÕıÏàÄÜÁ¿ÎªÒÀ¾İ²úÉúCF
             -        //
 143   1       
 144   1           // step11// 
 145   1          SetMeterCfgACK(0x01,DATACP);//Çå³£Êı¹¦ÂÊ¼Ä´æÆ÷ //
 146   1          P9OE&=(~(BIT5));//´ò¿ªCF2 IOÊä³ö//
 147   1          P9FC|=(BIT5);
 148   1      //    P1OE &=(~(BIT3));//´ò¿ªCF 1 IOÊä³ö//
 149   1      //    P13FS |=(BIT2);
 150   1          EIE|=0x02;
 151   1          ExInt3IE|=BIT7;     // ¿ªÆôCF2ÖĞ¶Ï //  ÓĞ¹¦ÖĞ¶Ï
 152   1      
 153   1          gs_emu_run_var.delay_emu = 3;   // ³õÊ¼»¯ºóµÄÎÈ¶¨Ê±¼äÎª2Ãë //
 154   1      
 155   1      #endif
 156   1      #if meter_type == D_1P2W
                      if(u8_mode==SLEEP_MODE)
                      {
                              CtrlADC5=0X80;     //¹Ø±ÕMÍ¨µÀ //
                              CtrlADC6=0;         //¹Ø±ÕËùÓĞAD²ÉÑù //  
                              PMG=1;              //¹Ø±Õ¼ÆÁ¿Ê±ÖÓ  //
                              return;
                      }
              
                      PMG=0;              //´ò¿ª¼ÆÁ¿Ê±ÖÓ  //
                      //step1  //
                      SetMeterCfgACK(0x00,PMCtrl4);   //¹Ø±ÕÄÜÁ¿ÀÛ¼Ó¡¢CF Êä³öÒÔ¼°Æğ¶¯/Ç±¶¯ÅĞ¶ÏµçÂ· //
                      SetMeterCfgACK(0x00,PMCtrl1);   // ¹Ø±Õ¼ÆÁ¿Í¨µÀ£¬²¢Í£Ö¹¹¦ÂÊ/ÓĞĞ§Öµ¼ÆËã  //
                      // step2  //
                      CtrlADC5=0x80;   
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 4   

                      CtrlADC6=0;   
                      if(u8_mode==NORMAL_MODE)
                      {
                              Set_EmuClock(EMUCLK_3M2);          // 3.2M ¼ÆÁ¿Ö÷Æµ //
                              ADCOPEN(ADCBPDN+ADCAPDN+ADCUPDN);//OPEN ADC U  A 
                              SetMeterCfgACK(0X889374BC,PARABPF);    // ÊÖ²áÒªÇó //
                      }
                      else if((u8_mode ==DLX_MODE)||(u8_mode ==CONST_MODE))
                      {
                              Set_EmuClock(EMUCLK_800k);       // 800K¼ÆÁ¿Ö÷Æµ //
                              ADCOPEN(ADCBPDN+ADCAPDN);//OPEN ADC  A 
                              SetMeterCfgACK(0X911D3C9C,PARABPF);    // ÊÖ²áÒªÇó // 
                      }
                      else
                      {
                              sys_err();          // ÊäÈë²ÎÊıÒì³££¬ËÀÑ­»·ÍË³ö //
                      }
                      CtrlADC0=(ADCA4X+ADCB4X+ADCU2X); //ADC A 4X GAIN  ADC B 4x GAIN ADC U 2sX GAIN  
              
                      // step3  //   
                      SetMeterCfgACK(INITGATEP,GATEP);//ÉèÖÃ¼ÆÁ¿³õÊ¼Öµ
                      SetMeterCfgACK(INITGATEQ,GATEQ);
              
              
                      // step7// 
                      SetMeterCfgACK(0x01,GATECP);//Ç±¶¯1   ,=1»á½ûÖ¹Âö³å·¢³ö    //
                      SetMeterCfgACK(0x01,GATECQ);//Ç±¶¯2   ,=1»á½ûÖ¹Âö³å·¢³ö  //
                      //    SetMeterCfgACK(0x00,DATACP);//Çå³£Êı¹¦ÂÊ¼Ä´æÆ÷ //
              
                      // step8//
                      SetMeterCfgACK(0x73,PMCtrl1); 
                      //SetMeterCfgACK(0x57,PMCtrl1);//BIT7= 0  ²âÊÔÎ»È·±£Îª0  ; BIT6=1 Ê¹ÄÜ½Ç²îĞ£Õı  //
                                                                                      //BIT5= 0  IA--I1,IB--I2 ; BIT4=1 Ê¹ÄÜPMÊı×ÖĞÅºÅ´¦Àí  //
                                                                                      //BIT3= 0  ÆÁ±ÎMÍ¨µÀÊı×ÖĞÅºÅÊäÈë; BIT2=1 Ê¹ÄÜI2Êı×ÖĞÅºÅÊäÈëÊ¹ÄÜ  //
                                                                                      //BIT1= 1   Ê¹ÄÜI1Êı×ÖĞÅºÅÊäÈëÊ¹ÄÜ; BIT0=1 Ê¹ÄÜUÊı×ÖĞÅºÅÊäÈëÊ¹ÄÜ  //
                      SetMeterCfgACK(0x00,PMCtrl2);// Êı×ÖÔöÒæÀàµÄ²ÎÊı¼Ä´æÆ÷£¬ÒªÇóÎª0  //
                      
                      SetMeterCfgACK(0x60,PMCtrl3);
                      // SetMeterCfgACK(0x70,PMCtrl3);//¿ªÆôÁ½Â·ÓĞ¹¦,´øÍ¨ºÍµÍÍ¨ÂË²¨Æ÷ÓĞĞ§ //
              
                      SetMeterCfgACK(0,0x10f0);    //0x10f0  PPCNT  ÕıÏò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷  //
                      SetMeterCfgACK(0,0x10f1);    //0x10f1  NPCNT  ·´Ïò E1 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷ //
                      SetMeterCfgACK(0,0x10f2);    //0x10f2  PPCFCNT  ÕıÏò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
                      SetMeterCfgACK(0,0x10f3);   //0x10f3  NPCFCNT  ·´Ïò E1 ÄÜÁ¿Âö³å¼ÆÊıÆ÷   //
                      SetMeterCfgACK(0,0x10f6);   //0x10f6  PQCNT  ÕıÏò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷//
                      SetMeterCfgACK(0,0x10f7);   //0x10f7  NQCNT  ·´Ïò E2 ÄÜÁ¿ÀÛ¼Ó¼Ä´æÆ÷   //
                      SetMeterCfgACK(0,0x10f8);   //0x10f8  PQCFCNT   ÕıÏò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
                      SetMeterCfgACK(0,0x10f9);   //0x10f9 NQCFCNT   ·´Ïò E2 ÄÜÁ¿Âö³å¼ÆÊıÆ÷  //
                      // step9 // 
                      SetMeterCfgACK(0x7F,PMCtrl4);//BIT7= 1  E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯ÅĞ¶ÏÊ¹ÄÜ  ; BIT6=1  E2 ¼ÆÁ¿Í¨µÀÆğ¶¯/Ç±¶¯ÅĞ¶ÏÊ
             -¹ÄÜ  //
                                                                              //BIT5= 0 E2 ÄÜÁ¿ CF Âö³åÊä³ö¹Ø±Õ; BIT4=1 Ê¹ÄÜE1 ÄÜÁ¿ CF Âö³åÊä³ö //
                                                                              //BIT3= 1 Ê¹ÄÜÄÜÁ¿ÀÛ¼ÓºÍÄÜÁ¿Âö³å¼ÆÊı; BIT2=0  E1 ÄÜÁ¿ CF Âö³å´ÓÒı½Å CF1 Êä³ö£¬E2 ÄÜÁ¿ CF Âö³å´ÓÒı½
             -Å CF2 Êä³ö  //
                                                                              //BIT1:0= 10 ³£Êı¹¦ÂÊ //
                      // step10 // 
                      SetMeterCfgACK(0,PHCCtrl1);//Çå0
                      SetMeterCfgACK(0,PHCCtrl2);//Çå0
              
                      SetMeterCfgACK(0x00,CFCtrl);           //ÒÔE2Õı·´¾ø¶ÔÖµÀÛ¼ÓÄÜÁ¿ÎªÒÀ¾İ²úÉúCF2  ÒÔE1ÕıÏàÄÜÁ¿ÎªÒÀ¾İ²úÉúCF  //
              
                       // step11// 
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 5   

                      SetMeterCfgACK(0x00,DATACP);//Çå³£Êı¹¦ÂÊ¼Ä´æÆ÷ //
                      P9OE&=(~(BIT5));//´ò¿ªCF2 IOÊä³ö//
                      P9FC|=(BIT5);
                      P9OE&=(~(BIT6));//´ò¿ªCF2 IOÊä³ö//
                      P9FC|=(BIT6);
                      EIE|=(0x02+0x01);
                      ExInt2IE|=BIT7;     // ¿ªÆôCF1ÖĞ¶Ï //  ÎŞ¹¦ÖĞ¶Ï
                      ExInt3IE|=BIT7;     // ¿ªÆôCF2ÖĞ¶Ï //  ÓĞ¹¦ÖĞ¶Ï
              
                      gs_emu_run_var.delay_emu = 3;   // ³õÊ¼»¯ºóµÄÎÈ¶¨Ê±¼äÎª2Ãë //
              
              #endif
 243   1      
 244   1      }
 245          /*******************************************************************************************
 246          ** º¯ÊıÃû³Æ: Lnk_get_EMU_voltage
 247          ** º¯ÊıÃèÊö: »ñÈ¡Ö¸¶¨Í¨µÀµçÑ¹ 
 248          ** ÊäÈë²ÎÊı: ch: Í¨µÀĞòºÅ0´ú±íºÏÏà
 249          ** Êä³ö²ÎÊı: uint32 Ö¸¶¨Í¨µÀµçÑ¹Öµ£¬HEXÂë,Á¿¸ÙÎª0.01V
 250          ** ËµÃ÷    : Ğ£±íÏµÊıÎª0.01V£¬/10×ªÎª0.1V
 251          *******************************************************************************************/
 252          uint32 Lnk_get_EMU_voltage(uint8 ch)
 253          {
 254   1          uint32 val,tmpval;
 255   1          fp32   f32_tmp;
 256   1          ST_U32_U08 TempValue;
 257   1          if(ch==WIRE_L1) 
 258   1          {    
 259   2              val= ReadMeterParaACK(RMSIU);   
 260   2              if(val>=0x80000000)
 261   2              {
 262   3                  val=~val+1;
 263   3              }       
 264   2              f32_tmp = (gs_adj_emu_param.vrms_xs*(fp32)val);
 265   2              tmpval = (uint32)f32_tmp;
 266   2          }
 267   1          else  if(ch==WIRE_L2)  
 268   1          {
 269   2              if(ReadRaccoon(RegAARTU,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ı    //  ÀíÂÛÊ±¼ä15ms  RegAARTU   
 270   2              {
 271   3                 memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 272   3                 Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 273   3                 val = TempValue.u32;
 274   3              }
 275   2              else // ¶ÁÈ¡Ê§°Ü£¬Ë¢ĞÂ´®¿Ú// 
 276   2              {
 277   3                  gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 278   3              }
 279   2      
 280   2              if(val>=0x80000000)
 281   2              {
 282   3                  val=~val+1;  
 283   3              }
 284   2              f32_tmp = gs_adj_emu_param.vrms_xs*(fp32)val;
 285   2              tmpval = (uint32)f32_tmp;
 286   2          }
 287   1          else
 288   1          {
 289   2              tmpval = 0;
 290   2          }
 291   1      
 292   1      
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 6   

 293   1          if( tmpval <50)   tmpval =0;
 294   1      
 295   1          return(tmpval);
 296   1      
 297   1      
 298   1      }
 299          /*******************************************************************************************
 300          ** º¯ÊıÃû³Æ: Lnk_get_EMU_current
 301          ** º¯ÊıÃèÊö: »ñÈ¡Ö¸¶¨Í¨µÀµçÁ÷
 302          ** ÊäÈë²ÎÊı: ch: Í¨µÀĞòºÅ0´ú±íºÏÏà
 303          ** Êä³ö²ÎÊı: uint32 Ö¸¶¨Í¨µÀµçÁ÷Öµ£¬HEXÂë,Á¿¸ÙÎª0.001A
 304          ** ËµÃ÷    : 
 305          *******************************************************************************************/
 306          uint32 Lnk_get_EMU_current(uint8 ch)
 307          {
 308   1         uint32 val,tmpval;
 309   1         fp32   f32_tmp;
 310   1      //   ST_U32_U08 TempValue;
 311   1      
 312   1          if(ch==WIRE_L1) 
 313   1          {
 314   2              val = ReadMeterParaACK(RMSII2);  
 315   2              if(val>=0x80000000)
 316   2              {
 317   3                  val=~val+1;  
 318   3              } 
 319   2              f32_tmp = gs_adj_emu_param.i2rms_xs*val;
 320   2              tmpval = (uint32)f32_tmp;
 321   2          }
 322   1          else  if(ch==WIRE_L2) 
 323   1          {
 324   2                      val = ReadMeterParaACK(RMSII1);
 325   2                      if(val>=0x80000000)
 326   2                      {
 327   3                              val=~val+1;  
 328   3                      } 
 329   2                      f32_tmp = gs_adj_emu_param.i2rms_xs*val;
 330   2                      tmpval = (uint32)f32_tmp;
 331   2      
 332   2          }
 333   1          else
 334   1          {
 335   2              tmpval = 0;
 336   2          }
 337   1      
 338   1          if( tmpval <20)   tmpval =0;
 339   1      
 340   1          return (tmpval);
 341   1      
 342   1      }
 343          /*******************************************************************************************
 344          ** º¯ÊıÃû³Æ: Lnk_get_EMU_activePower
 345          ** º¯ÊıÃèÊö: »ñÈ¡Ö¸¶¨Í¨µÀµçÁ÷
 346          ** ÊäÈë²ÎÊı: ch: Í¨µÀĞòºÅ
 347          ** Êä³ö²ÎÊı: uint32 Ö¸¶¨Í¨µÀ¹¦ÂÊÖµ£¬HEXÂë,Á¿¸ÙÎª0.1W
 348          ** ËµÃ÷    : 
 349          *******************************************************************************************/
 350          uint32 Lnk_get_EMU_activePower(uint8 ch)
 351          {
 352   1         uint32 val,val2,tmpval;
 353   1         fp32   f32_tmp;
 354   1         ST_U32_U08 TempValue;
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 7   

 355   1      
 356   1          if(ch==PHASE_TT) 
 357   1          {
 358   2            val=ReadMeterParaACK(DATAIP);      
 359   2                if(ReadRaccoon(RegAAP,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ı    //  ÀíÂÛÊ±¼ä15ms
 360   2                {
 361   3             memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 362   3             Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 363   3             val2 = TempValue.u32;
 364   3                }
 365   2                 else // ¶ÁÈ¡Ê§°Ü£¬Ë¢ĞÂ´®¿Ú// 
 366   2                {
 367   3                 gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 368   3                }     
 369   2                 
 370   2                tmpval = val+val2;
 371   2          }
 372   1          if(ch==WIRE_L1) 
 373   1          {
 374   2      //       gs_emu_run_var.net_flg &= ~REV_L_ACPOWER;
 375   2             val=ReadMeterParaACK(DATAIP);     
 376   2             if(val>=0x80000000)
 377   2             {
 378   3                      val=~val+1;  
 379   3      //              gs_emu_run_var.net_flg |= REV_L_ACPOWER;
 380   3             }
 381   2                                      
 382   2          }
 383   1         else  if(ch==WIRE_L2) 
 384   1          {
 385   2      //    gs_emu_run_var.net_flg &= ~REV_N_ACPOWER;
 386   2              if(ReadRaccoon(RegAAP,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ı    //  ÀíÂÛÊ±¼ä15ms
 387   2              {
 388   3             memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 389   3             Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 390   3             val = TempValue.u32;
 391   3              }
 392   2              else // ¶ÁÈ¡Ê§°Ü£¬Ë¢ĞÂ´®¿Ú// 
 393   2              {
 394   3                  gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 395   3              }
 396   2      
 397   2           if(val>=0x80000000)
 398   2           {
 399   3                val=~val+1; 
 400   3      //        gs_emu_run_var.net_flg |= REV_N_ACPOWER;  
 401   3            } 
 402   2          }
 403   1          else
 404   1          {
 405   2              val = 0;
 406   2          }
 407   1      
 408   1          if(val<REF_START_Pn)
 409   1          {
 410   2              tmpval =0;    
 411   2      //        if(ch==WIRE_L1) gs_emu_run_var.net_flg &= ~REV_L_ACPOWER;
 412   2      //       if(ch==WIRE_L2) gs_emu_run_var.net_flg &= ~REV_N_ACPOWER;
 413   2          }
 414   1          else
 415   1          {
 416   2              if(ch==WIRE_L1) f32_tmp = cst_adj_const.Kim_Prms*val;
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 8   

 417   2              if(ch==WIRE_L2) f32_tmp = cst_adj_const.Kim_Prms*val;
 418   2              tmpval = (uint32)f32_tmp;               
 419   2          }
 420   1      
 421   1      
 422   1         if((gs_emu_run_var.net_flg&REV_L_ACPOWER)||(gs_emu_run_var.net_flg&REV_N_ACPOWER))
 423   1          {
 424   2      //      gs_measure_status_judge_var.u8_status |= REV_ACPOWER_L ;
 425   2           }
 426   1         else 
 427   1          {
 428   2      //     gs_measure_status_judge_var.u8_status &=~ REV_ACPOWER_L ;
 429   2          }
 430   1         
 431   1      
 432   1          return (tmpval);
 433   1      }
 434          /*******************************************************************************************
 435          ** º¯ÊıÃû³Æ: Lnk_get_EMU_freq
 436          ** º¯ÊıÃèÊö: »ñÈ¡Ö¸¶¨Í¨µÀµçÍøÆµÂÊ
 437          ** ÊäÈë²ÎÊı: ch: Í¨µÀĞòºÅ0´ú±íºÏÏà
 438          ** Êä³ö²ÎÊı: uint32 Ö¸¶¨Í¨µÀÆµÂÊÖµ£¬HEXÂë,Á¿¸ÙÎª0.01Hz
 439          ** ËµÃ÷    : 
 440          *******************************************************************************************/
 441          uint32 Lnk_get_EMU_freq(uint8 ch)
 442          {
 443   1              uint32 val,tmpval;
 444   1              ST_U32_U08 TempValue;
 445   1          if(ch==WIRE_L1) 
 446   1          {    
 447   2              val= ReadMeterParaACK(DATAFREQ);          
 448   2              tmpval= (819200 *100)/val;                      // 819200ÎªADC ÆµÂÊ  //
 449   2          }
 450   1         else  if(ch==WIRE_L2) 
 451   1              {
 452   2              if(ReadRaccoon(RegFREQ,1,BPhy)==TRUE)     // ÆµÂÊË²Ê±Öµ
 453   2              {
 454   3                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 455   3                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 456   3                      val = TempValue.u32;
 457   3                      tmpval= (819200 *100*4)/val;                    // 819200ÎªADC ÆµÂÊ  //
 458   3              }
 459   2              else // ¶ÁÈ¡Ê§°Ü£¬Ë¢ĞÂ´®¿Ú// 
 460   2              {
 461   3                  gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 462   3              }
 463   2          }
 464   1          else
 465   1          {
 466   2              tmpval = 0;
 467   2          }
 468   1      #if (C_Fq == 60)
 469   1                      tmpval = tmpval*1.2;
 470   1      #else
                              tmpval = tmpval; 
              #endif           
 473   1          return(tmpval);
 474   1      }
 475          
 476          /*******************************************************************************************
 477          ** º¯ÊıÃû³Æ: Lnk_CAL_EMU_constSum
 478          ** º¯ÊıÃèÊö: ³£Á¿¼ÆÁ¿Ã¿Ãë¸üĞÂÊı¾İ
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 9   

 479          ** ÊäÈë²ÎÊı: 
 480          ** Êä³ö²ÎÊı: 
 481          ** ËµÃ÷    : 
 482          *******************************************************************************************/
 483          void lnk_CAL_EMU_constSum_per_second(void)
 484          {
 485   1              ST_U32_U08 sumval0;
 486   1              ST_U32_U08 val1;
 487   1      //      ST_U32_U08 val2;
 488   1      //      ST_U32_U08 TempValue;
 489   1      
 490   1              //gs_emu_run_var.net_flg &= (~REV_TT_ACPOWER);
 491   1      
 492   1              //¶ÁÈ¡ÓĞÎŞ¹¦¼ÆÁ¿Ä£Ê½×Ö
 493   1              //  mem_read(&gs_sys_globaL_var.fac_energy[0], ADR_METER_PARAM1_FAC_ENERGY, 2, MEM_E2P1);   
 494   1              //  mem_read(&gs_sys_globaL_var.Rac_energy[0], ADR_METER_PARAM1_REC_ENERGY, 2, MEM_E2P1);    
 495   1              //9260FÎŞ¹¦¹¦ÂÊĞ´Èë//
 496   1              //Lnk_get_EMU_ractive_const();
 497   1      
 498   1              //ÓĞ¹¦¹¦ÂÊĞ´Èë//
 499   1          val1.u32 = 0;
 500   1      
 501   1              //¹¦ÂÊ»ñÈ¡ //
 502   1      #if meter_type == D_1P3W
 503   1              val1.u32+=ReadMeterParaACK(DATAIP);
 504   1              val1.u32+=ReadMeterParaACK(DATAIQ);     
 505   1      
 506   1              if(val1.u32>=0x80000000)
 507   1              {
 508   2                      gs_emu_run_var.net_flg &= (~REV_TT_ACPOWER);
 509   2                      val1.u32=~val1.u32+1;  
 510   2              //      gs_emu_run_var.net_flg |= REV_TT_ACPOWER;// ºÏÏà¹¦ÂÊ·´Ïò
 511   2              }
 512   1              else
 513   1                      gs_emu_run_var.net_flg |= REV_TT_ACPOWER;// ºÏÏà¹¦ÂÊ·´Ïò
 514   1      //      sumval0.u32=REF_START_Pn;
 515   1              sumval0.u32=val1.u32;
 516   1              if(val1.u32<REF_START_Pn) 
 517   1              {
 518   2                      sumval0.u32=0;
 519   2                      val1.u32 = 0;
 520   2                      gs_emu_run_var.net_flg &= (~REV_TT_ACPOWER);//ÆÁ±Î·´ÏòÖ¸Ê¾
 521   2              }
 522   1              sumval0.u32 /= 2;
 523   1              SetMeterCfgACK(sumval0.u32,DATACP); 
 524   1              gs_measure_var_data.gs_really[PHASE_TT].dw_p_val.u32 = cst_adj_const.Kim_Prms*val1.u32;
 525   1      #endif
 526   1      
 527   1      #if meter_type == D_1P2W
              //ÓĞ¹¦´¦Àí
                      val1.u32=ReadMeterParaACK(DATAIP);
                      if(val1.u32>=0x80000000)
                      {
                              gs_emu_run_var.net_flg &= (~REV_TT_ACPOWER);
                              val1.u32=~val1.u32+1;  
                      //      gs_emu_run_var.net_flg |= REV_TT_ACPOWER;// ºÏÏà¹¦ÂÊ·´Ïò
                      }
                      else
                              gs_emu_run_var.net_flg |= REV_TT_ACPOWER;// ºÏÏà¹¦ÂÊ·´Ïò
              //      sumval0.u32=REF_START_Pn;
                      sumval0.u32=val1.u32;
                      if(val1.u32<REF_START_Pn) 
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 10  

                      {
                              sumval0.u32=0;
                              val1.u32 = 0;
                              gs_emu_run_var.net_flg &= (~REV_TT_ACPOWER);//ÆÁ±Î·´ÏòÖ¸Ê¾
                      }
                      SetMeterCfgACK(sumval0.u32,DATACP); 
                      gs_measure_var_data.gs_really[PHASE_TT].dw_p_val.u32 = cst_adj_const.Kim_Prms*val1.u32;
              //ÎŞ¹¦´¦Àí
                      val1.u32=ReadMeterParaACK(DATAIQ);
                      if(val1.u32>=0x80000000)
                      {
                              val1.u32=~val1.u32+1;  
                      }
              //      else
              //              gs_emu_run_var.net_flg |= REV_TT_ACPOWER;// ºÏÏà¹¦ÂÊ·´Ïò
                              
                      sumval0.u32=val1.u32;
                      if(val1.u32<REF_START_Pn) 
                      {
                              sumval0.u32=0;
                              val1.u32 = 0;
                      }
                      gs_measure_var_data.gs_really[PHASE_TT].dw_q_val.u32 = cst_adj_const.Kim_Prms2*val1.u32/1.568;
              #endif
 565   1      
 566   1      }
 567          
 568          
 569          /*******************************************************************************************
 570          ** º¯ÊıÃû³Æ: 
 571          ** º¯ÊıÃèÊö: »ñÈ¡ÎŞ¹¦¹¦ÂÊ
 572          ** ÊäÈë²ÎÊı: 
 573          ** Êä³ö²ÎÊı: 
 574          ** ËµÃ÷    : 
 575          *******************************************************************************************/
 576          void Lnk_get_EMU_ractive_const(void)
 577          {
 578   1              ST_U32_U08 Temp_paraqc;
 579   1              ST_U32_U08 val1,sumval1;
 580   1              ST_U32_U08 val2,sumval2;
 581   1              ST_U32_U08 TempValue;
 582   1              float err_ec;
 583   1              
 584   1              val1.u32 = 0;
 585   1              Temp_paraqc.u32 = 0;
 586   1              val2.u32 = 0;
 587   1              //¶ÁÈ¡AÂ·ÎŞ¹¦
 588   1              val1.u32=ReadMeterParaACK(DATAIQ);          
 589   1              // ¶ÁÈ¡¶ş´Î²¹³¥¼Ä´æÆ÷
 590   1              Temp_paraqc.u32=ReadMeterParaACK(PARAQC);
 591   1              
 592   1              //BÂ·¹¦ÂÊÒÔ¼°µçÑ¹µçÁ÷»ñÈ¡»ñÈ¡9260F  //
 593   1              if(ReadRaccoon(RegAAQ,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ı    //  ÀíÂÛÊ±¼ä76ms  RegIAP
 594   1              {
 595   2                      memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 596   2                      Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//'
 597   2                      val2.u32= TempValue.u32*1.669f; //0.01%¾«¶È
 598   2              }
 599   1              else 
 600   1              {
 601   2                      gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 602   2                      return;
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 11  

 603   2              }
 604   1      
 605   1              if((sumval1.u32 <= REF_START_Pn)||(sumval1.u32 >= REF_START_REV_Pn))// ÎŞ¹¦Æô¶¯
 606   1              {
 607   2                      sumval1.u32 =0; 
 608   2              }
 609   1              
 610   1              if((sumval2.u32 <= REF_START_Pn)||(sumval2.u32 >= REF_START_REV_Pn))// ÎŞ¹¦Æô¶¯
 611   1              {
 612   2                      sumval2.u32 =0; 
 613   2              }
 614   1      
 615   1      
 616   1              //ÌáÈ¡ºÏÏàÒÔ¼°·ÖÏà·½Ïò//
 617   1              if(val1.u32>=0x80000000)
 618   1              {
 619   2              //       gs_emu_run_var.net_flg |= REV_TT_RACPOWER; // ºÏÏà·´Ïò
 620   2              }
 621   1              else
 622   1              {
 623   2              //      gs_emu_run_var.net_flg &= (~REV_TT_RACPOWER); // ºÏÏà·´Ïò
 624   2              }
 625   1      
 626   1              if(val2.u32>=0x80000000)
 627   1              {
 628   2              //              gs_emu_run_var.net_flg |= REV_N_RACPOWER; // BÂ··´Ïò //
 629   2              }
 630   1              else
 631   1              {
 632   2              //              gs_emu_run_var.net_flg &= (~REV_N_RACPOWER); // BÂ·ÕıÏò//
 633   2              }
 634   1      
 635   1                
 636   1                //¸ù¾İºÏÏàÒÔ¼°BÂ·´óĞ¡£¬ÅĞ¶ÏAÂ··½Ïò//
 637   1      //        if(Temp_paraqc.u32==0) // ¶ş´Î²¹³¥¼Ä´æÆ÷
 638   1      //        {
 639   1      //        if((gs_emu_run_var.net_flg&REV_TT_RACPOWER)!=REV_TT_RACPOWER) // AÂ·ÕıÏò
 640   1      //        {
 641   1      //             if(gs_emu_run_var.net_flg&REV_N_RACPOWER) //ÎŞ¹¦ BÂ··´ÏòÖ±½Ó¶ªÈë 
 642   1      //             {
 643   1      //               if(gs_sys_globaL_var.Rac_energy[0]==0x55) //´úÊıºÍ
 644   1      //               {
 645   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 646   1      //               }
 647   1      //                       else
 648   1      //                       {
 649   1      //                        val2.u32 = val2.u32; //Ö±½Ó¶ªÈë
 650   1      //                       }
 651   1      //                 }
 652   1      //                 else 
 653   1      //                 {
 654   1      //               if(gs_sys_globaL_var.Rac_energy[0]==0x55) //´úÊıºÍ
 655   1      //               {
 656   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 657   1      //               }
 658   1      //                       else
 659   1      //                       {
 660   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 661   1      //                       }
 662   1      //                 }
 663   1      //        }
 664   1      //              else  //AÂ··´
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 12  

 665   1      //              {
 666   1      //             if(gs_emu_run_var.net_flg&REV_N_RACPOWER) //ÎŞ¹¦ BÂ··´ÏòÖ±½Ó¶ªÈë 
 667   1      //             {
 668   1      //               if(gs_sys_globaL_var.Rac_energy[0]==0x55) //´úÊıºÍ
 669   1      //               {
 670   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 671   1      //               }
 672   1      //                       else
 673   1      //                       {
 674   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 675   1      //                       }
 676   1      //                 }
 677   1      //                 else 
 678   1      //                 {
 679   1      //               if(gs_sys_globaL_var.Rac_energy[0]==0x55) //´úÊıºÍ
 680   1      //               {
 681   1      //                        val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 682   1      //               }
 683   1      //                       else
 684   1      //                       {
 685   1      //                        val2.u32=val2.u32;  // Ö±½Ó¶ªÈë
 686   1      //                       }
 687   1      //                 }
 688   1      //        }
 689   1      //           // 9260F ÎŞ¹¦Ğ´Èë¶ş´Î²¹³¥¼Ä´æÆ÷ 2^31/(2^31*gs_adj_emu_param.w1gain*sumval2.u32*(2.175/1.2/1.086))/
             -/
 690   1      //           err_ec = (float)((float)(0x80000000/(float)(0x80000000+gs_adj_emu_param.w1gain)));
 691   1      //               val2.u32 =  val2.u32*err_ec ;
 692   1      //               SetMeterCfgACK( val2.u32,PARAQC);
 693   1      //           gs_measure_var_data.gs_really[PHASE_TT].dw_q_val.u32 = cst_adj_const.Kim_Prms2*sumval0.u32;
 694   1      //           gs_measure_var_data.gs_really[WIRE_L1].dw_q_val.u32 = cst_adj_const.Kim_Prms2*val1.u32;
 695   1      //           gs_measure_var_data.gs_really[WIRE_L2].dw_q_val.u32 = cst_adj_const.Kim_Prms2*val2.u32;
 696   1      //        }
 697   1      //        else
 698   1      //        {
 699   1              if((gs_emu_run_var.net_flg&REV_TT_RACPOWER)!=REV_TT_RACPOWER) // AÂ·ÕıÏò
 700   1              {
 701   2                     if(gs_emu_run_var.net_flg&REV_N_RACPOWER) //ÎŞ¹¦ BÂ··´ÏòÖ±½Ó¶ªÈë 
 702   2                     {
 703   3                                val2.u32=~val2.u32+1;  //
 704   3                               //{
 705   3                                 //if(val1.u32 >= val2.u32)
 706   3      //                         gs_emu_run_var.net_flg|REV_L_RACPOWER ;  //A·ûºÅ
 707   3                                 TempValue.u32 = val2.u32+ val1.u32;     //AÂ·¹¦ÂÊÖµ
 708   3                                 //È«²¿È¡·´¶ªÈë
 709   3                               //}
 710   3                         
 711   3                         }
 712   2                         else //ÎŞ¹¦BÂ·Õı
 713   2                         {
 714   3                                 if(val1.u32 >= val2.u32)
 715   3                                 {
 716   4                                   TempValue.u32 = val1.u32 - val2.u32 ;        //AÂ·¹¦ÂÊÖµ
 717   4      //                           gs_emu_run_var.net_flg&=(~REV_L_RACPOWER);   //A·ûºÅ
 718   4                                       val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 719   4                                 }
 720   3                                 else
 721   3                                 {
 722   4      //                           gs_emu_run_var.net_flg|REV_L_RACPOWER;   //A·ûºÅ
 723   4                                   TempValue.u32 = val2.u32 - val1.u32 ;   //AÂ·¹¦ÂÊÖµ
 724   4                                       if(gs_sys_globaL_var.Rac_energy[0]==0x55) //´úÊıºÍ
 725   4                                       {
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 13  

 726   5                                         val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 727   5                                       }
 728   4                                 }
 729   3                         }
 730   2              }
 731   1                      else  //AÂ··´
 732   1                      {
 733   2                     if(gs_emu_run_var.net_flg&REV_N_RACPOWER) //ÎŞ¹¦ BÂ··´ÏòÖ±½Ó¶ªÈë 
 734   2                     {
 735   3                                 if(val1.u32 >= val2.u32)
 736   3                                 {
 737   4                                   TempValue.u32 = val1.u32 - val2.u32 ;        //AÂ·¹¦ÂÊÖµ
 738   4      //                           gs_emu_run_var.net_flg|=REV_L_RACPOWER;   //A·ûºÅ
 739   4                                       if(gs_sys_globaL_var.Rac_energy[0]!=0x55)   //´úÊıºÍ
 740   4                                       {
 741   5                                         val2.u32= val2.u32;    //Ö±½Ó¶ªÈë
 742   5                                       }
 743   4                                       else
 744   4                                       {
 745   5                                         val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 746   5                                       }
 747   4                                      }
 748   3                                 else
 749   3                                 {
 750   4      //                           gs_emu_run_var.net_flg&=(~REV_L_RACPOWER);   //A·ûºÅ
 751   4                                   TempValue.u32 = val2.u32 - val1.u32 ;       //AÂ·¹¦ÂÊÖµ
 752   4                                       val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 753   4                                 }
 754   3                         }
 755   2                         else //ÎŞ¹¦BÂ·Õı
 756   2                         {
 757   3                                   TempValue.u32 = val1.u32 + val2.u32 ;        //AÂ·¹¦ÂÊÖµ
 758   3      //                           gs_emu_run_var.net_flg|=REV_L_RACPOWER;   //A·ûºÅ
 759   3                                       if(gs_sys_globaL_var.Rac_energy[0]!=0x55)   //´úÊıºÍ
 760   3                                       {
 761   4                                         val2.u32= val2.u32;    //Ö±½Ó¶ªÈë
 762   4                                       }
 763   3                                       else
 764   3                                       {
 765   4                                         val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 766   4                                       }
 767   3                         }
 768   2              }
 769   1                      
 770   1                   // 9260F ÎŞ¹¦Ğ´Èë¶ş´Î²¹³¥¼Ä´æÆ÷ 2^31/(2^31*gs_adj_emu_param.w1gain*sumval2.u32*(2.175/1.2/1.086))//
 771   1                   err_ec = (float)((float)(0x80000000/(float)(0x80000000+gs_adj_emu_param.w1gain)));
 772   1      
 773   1                       if(val2.u32>0x80000000)
 774   1                       {
 775   2                    val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 776   2                        val2.u32 =  val2.u32*err_ec ;
 777   2                    val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
 778   2                       }
 779   1                       else  val2.u32 =  val2.u32*err_ec ;
 780   1      
 781   1                       SetMeterCfgACK(val2.u32,PARAQC);
 782   1      //        }
 783   1      
 784   1                  //ÓĞĞ§Öµ»ñÈ¡//
 785   1                      if(val2.u32>0x80000000)
 786   1                      {
 787   2                    val2.u32=~val2.u32+1;  // È¡·´¶ªÈë
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 14  

 788   2                      }
 789   1                      
 790   1                  if(val1.u32>0x80000000)
 791   1                      {
 792   2                    val1.u32=~val1.u32+1;  // È¡·´¶ªÈë
 793   2                      }       
 794   1                  if(TempValue.u32>0x80000000)
 795   1                      {
 796   2                    TempValue.u32=~TempValue.u32+1;  // È¡·´¶ªÈë
 797   2                      }               
 798   1                      gs_measure_var_data.gs_really[PHASE_TT].dw_q_val.u32 = cst_adj_const.Kim_Prms2*val1.u32;
 799   1                      gs_measure_var_data.gs_really[WIRE_L1].dw_q_val.u32 = cst_adj_const.Kim_Prms2*TempValue.u32;
 800   1                      gs_measure_var_data.gs_really[WIRE_L2].dw_q_val.u32 = cst_adj_const.Kim_Prms2*val2.u32;
 801   1                      gs_measure_var_data.gs_really[WIRE_L3].dw_q_val.u32 = 0;
 802   1      
 803   1      }
 804          
 805          
 806          /*******************************************************************************************
 807          ** º¯ÊıÃû³Æ: Lnk_get_EMU_activePower
 808          ** º¯ÊıÃèÊö: »ñÈ¡ÎŞ¹¦¹¦ÂÊ
 809          ** ÊäÈë²ÎÊı: ch: Í¨µÀĞòºÅ
 810          ** Êä³ö²ÎÊı: uint32 Ö¸¶¨Í¨µÀ¹¦ÂÊÖµ£¬HEXÂë,Á¿¸ÙÎª0.1W
 811          ** ËµÃ÷    : 
 812          *******************************************************************************************/
 813          uint32 Lnk_get_EMU_ractivePower(uint8 ch)
 814          {
 815   1         uint32 val,tmpval;
 816   1         fp32   f32_tmp;
 817   1         ST_U32_U08 TempValue;
 818   1      
 819   1          if(ch==WIRE_L1) 
 820   1          {
 821   2      //       gs_emu_run_var.net_flg &= ~REV_L_RACPOWER;
 822   2                 val=ReadMeterParaACK(DATAIQ);         
 823   2             if(val>=0x80000000)
 824   2             {
 825   3                      val=~val+1; 
 826   3      //              gs_emu_run_var.net_flg |= REV_L_RACPOWER;
 827   3             }
 828   2          }
 829   1              
 830   1          else  if(ch==WIRE_L2) 
 831   1          {
 832   2              if(ReadRaccoon(RegAAQ,1,BPhy)==TRUE)     // ×î´ó 200ms¶ÁÈ¡µÈ´ı    //  ÀíÂÛÊ±¼ä15ms
 833   2              {
 834   3             memcpy((uint8*)TempValue.B08,gs_RacCtrl.ucBuf+3,4); //ÓĞ¹¦ÃëÆ½¾ù¹¦ÂÊ
 835   3             Lib_Rev_Copy_Arry(&TempValue.B08[0],4);// µÍ×Ö½ÚÔÚÇ°  µ¹ÖÃ//
 836   3             val = TempValue.u32;
 837   3              }
 838   2              else // ¶ÁÈ¡Ê§°Ü£¬Ë¢ĞÂ´®¿Ú// 
 839   2              {
 840   3                  gs_sys_run.font_fg |= BIT4_FONT_FG_EnyBottom;
 841   3              }
 842   2      //      gs_emu_run_var.net_flg &= ~REV_N_RACPOWER;
 843   2      
 844   2             if(val>=0x80000000)
 845   2             {
 846   3                      val=~val+1; 
 847   3      //              gs_emu_run_var.net_flg |= REV_N_RACPOWER;
 848   3             }
 849   2      
C51 COMPILER V9.01   LNK_EMU_HANDL                                                         04/08/2019 10:12:07 PAGE 15  

 850   2                 val = val*1.669;//2.175f/1.2f*1.086f;
 851   2          }
 852   1          else
 853   1          {
 854   2              val = 0;
 855   2          }
 856   1      
 857   1          if(val<REF_START_Pn)
 858   1          {
 859   2              tmpval =0;    
 860   2      //        if(ch==WIRE_L1) gs_emu_run_var.net_flg &= ~REV_L_RACPOWER;
 861   2      //        if(ch==WIRE_L2) gs_emu_run_var.net_flg &= ~REV_N_RACPOWER;
 862   2          }
 863   1          else
 864   1          {
 865   2              
 866   2              if(ch==WIRE_L1) f32_tmp = cst_adj_const.Kim_Prms2*val;
 867   2              if(ch==WIRE_L2) f32_tmp = cst_adj_const.Kim_Prms2*val;
 868   2              tmpval = (uint32)f32_tmp;               
 869   2          }
 870   1              
 871   1          return (tmpval);
 872   1      }
 873          
 874          /*******************************************************************************************
 875          **    END
 876          *******************************************************************************************/
 877          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4263    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3     118
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
